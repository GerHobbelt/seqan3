// -*- C++ -*-
// -----------------------------------------------------------------------------------------------------
// Copyright (c) 2006-2020, Knut Reinert & Freie Universität Berlin
// Copyright (c) 2016-2020, Knut Reinert & MPI für molekulare Genetik
// This file may be used, modified and/or redistributed under the terms of the 3-clause BSD-License
// shipped with this file and also available at: https://github.com/seqan/seqan3/blob/master/LICENSE.md
// -----------------------------------------------------------------------------------------------------

/*!\file
 * \brief The Concepts library.
 * \author Hannes Hauswedell <hannes.hauswedell AT fu-berlin.de>
 */

#pragma once

#if __has_include(<concepts>)
#include <concepts>
#endif // __has_include(<concepts>)

#ifdef __cpp_lib_concepts        // C++20 concepts available

namespace std
{
inline namespace deprecated
{
/*!\brief This should be removed.
 * \deprecated No viable alternative.
 */
template <class B>
concept boolean =
    movable<std::remove_cvref_t<B>> &&
    requires(std::remove_reference_t<B> const & b1,
             std::remove_reference_t<B> const & b2, bool const a)
    {
        requires convertible_to<const std::remove_reference_t<B>&, bool>;
        !b1;      requires convertible_to<decltype(!b1), bool>;
        b1 && a;  requires same_as<decltype(b1 && a), bool>;
        b1 || a;  requires same_as<decltype(b1 || a), bool>;
        b1 && b2; requires same_as<decltype(b1 && b2), bool>;
        a && b2;  requires same_as<decltype(a && b2), bool>;
        b1 || b2; requires same_as<decltype(b1 || b2), bool>;
        a || b2;  requires same_as<decltype(a || b2), bool>;
        b1 == b2; requires convertible_to<decltype(b1 == b2), bool>;
        b1 == a;  requires convertible_to<decltype(b1 == a), bool>;
        a == b2;  requires convertible_to<decltype(a == b2), bool>;
        b1 != b2; requires convertible_to<decltype(b1 != b2), bool>;
        b1 != a;  requires convertible_to<decltype(b1 != a), bool>;
        a != b2;  requires convertible_to<decltype(a != b2), bool>;
    };
} // inline namespace std::deprecated
} // namespace std

namespace std::detail
{
/*!\interface   std::detail::weakly_equality_comparable_with <>
 * \tparam t1   The first type to compare.
 * \tparam t2   The second type to compare.
 * \brief       Requires the two operands to be comparable with `==` and `!=` in both directions.
 * \sa          https://en.cppreference.com/w/cpp/concepts/equality_comparable
 */
//!\cond
template <class T, class U>
concept weakly_equality_comparable_with =
    requires(std::remove_reference_t<T> const & t,
             std::remove_reference_t<U> const & u)
    {
        t == u; requires boolean<decltype(t == u)>;
        t != u; requires boolean<decltype(t != u)>;
        u == t; requires boolean<decltype(u == t)>;
        u != t; requires boolean<decltype(u != t)>;
    };
//!\endcond
} // namespace std::detail

#else                         // use range-v3 to emulate

#include <functional>
#include <type_traits>

#include <concepts/concepts.hpp>
#include <range/v3/functional/concepts.hpp>

#include <seqan3/core/type_traits/basic.hpp>

/*!\defgroup std std
 * \brief A subset of the C++20 standard library made available in pre-C++20 contexts.
 *
 * \details
 *
 * This module provides many parts of the C++20 standard library (and some parts of the C++17 standard library
 * not available in GCC). They are only defined if not found in the compiler's standard library and are called exactly
 * like the originals so they can be used interchangeably. The actual implementation is provided by us or aliased
 * from the range-v3 library.
 *
 * \attention All of this sub-module is subject to change!
 *
 * In particular:
 *
 *   * We do not provide all C++20 library features, only those that are used by SeqAn.
 *   * All of these might change or be removed until C++20 is published.
 *   * The documentation of this module will likely be removed entirely in favour of links to
 *     https://en.cppreference.com
 *
 * It is best you consider every entity in this module as:
 *
 * \noapi
 *
 */

/*!\defgroup concepts concepts
 * \ingroup std
 * \brief The \<concepts\> header from C++20's standard library.
 */

// see https://github.com/seqan/seqan3/projects/19#card-27177080 :
#if 0
namespace std
{

namespace
{

// from concept/concepts.hpp (also range-v3)
using namespace ::concepts;

// missing from range-v3
template <class B>
SEQAN3_CONCEPT boolean =
    movable<seqan3::remove_cvref_t<B>> &&
    requires(std::remove_reference_t<B> const & b1,
             std::remove_reference_t<B> const & b2, bool const a)
    {
        requires convertible_to<const std::remove_reference_t<B>&, bool>;
        !b1;      requires convertible_to<decltype(!b1), bool>;
        b1 && a;  requires same_as<decltype(b1 && a), bool>;
        b1 || a;  requires same_as<decltype(b1 || a), bool>;
        b1 && b2; requires same_as<decltype(b1 && b2), bool>;
        a && b2;  requires same_as<decltype(a && b2), bool>;
        b1 || b2; requires same_as<decltype(b1 || b2), bool>;
        a || b2;  requires same_as<decltype(a || b2), bool>;
        b1 == b2; requires convertible_to<decltype(b1 == b2), bool>;
        b1 == a;  requires convertible_to<decltype(b1 == a), bool>;
        a == b2;  requires convertible_to<decltype(a == b2), bool>;
        b1 != b2; requires convertible_to<decltype(b1 != b2), bool>;
        b1 != a;  requires convertible_to<decltype(b1 != a), bool>;
        a != b2;  requires convertible_to<decltype(a != b2), bool>;
  };

// from range/v3/functional/concepts.hpp
using ::ranges::invocable;
using ::ranges::predicate;
using ::ranges::regular_invocable;
using ::ranges::relation;
using ::ranges::strict_weak_order;

} // anonymous namespace

} // namespace std

#else  // old code

#include <range/v3/utility/common_type.hpp>

namespace std
{

//!\addtogroup concepts
//!\{

// ============================================================================
//  Core language concepts
// ============================================================================

using ::concepts::same_as;
using ::concepts::derived_from;
using ::concepts::convertible_to;
using ::concepts::common_reference_with;
using ::concepts::common_with;
using ::concepts::integral;
using ::concepts::signed_integral;
using ::concepts::unsigned_integral;

/*!\interface std::floating_point <>
 * \brief The concept std::floating_point<T> is satisfied if and only if T is a floating-point type.
 * \sa https://en.cppreference.com/w/cpp/types/is_floating_point
 */
//!\cond
template <typename t>
SEQAN3_CONCEPT floating_point = std::is_floating_point_v<t>;
// using ::concepts::floating_point;
//!\endcond

using ::concepts::assignable_from;
using ::concepts::swappable;
using ::concepts::swappable_with;
using ::concepts::destructible;
using ::concepts::constructible_from;

/*!\interface   std::default_initializable <>
 * \extends     std::constructible_from
 * \brief       The std::default_initializable concept provides a shorthand for the common case when the question is whether
 *              a type can be constructed with no arguments.
 * \sa          https://en.cppreference.com/w/cpp/concepts/default_initializable
 */
//!\cond
template <class T>
SEQAN3_CONCEPT default_initializable = ::concepts::default_constructible<T>;
// using ::concepts::default_constructible;
//!\endcond
using ::concepts::move_constructible;
using ::concepts::copy_constructible;
using ::concepts::movable;

// ============================================================================
//  Comparison concepts
// ============================================================================

/*!\interface   std::boolean <>
 * \extends     std::movable
 * \brief       Specifies that a type can be used in boolean contexts.
 * \sa          https://en.cppreference.com/w/cpp/concepts/boolean
 */
//!\cond
template <class B>
SEQAN3_CONCEPT boolean =
    movable<seqan3::remove_cvref_t<B>> &&
    requires(std::remove_reference_t<B> const & b1,
             std::remove_reference_t<B> const & b2, bool const a)
    {
        requires convertible_to<const std::remove_reference_t<B>&, bool>;
        !b1;      requires convertible_to<decltype(!b1), bool>;
        b1 && a;  requires same_as<decltype(b1 && a), bool>;
        b1 || a;  requires same_as<decltype(b1 || a), bool>;
        b1 && b2; requires same_as<decltype(b1 && b2), bool>;
        a && b2;  requires same_as<decltype(a && b2), bool>;
        b1 || b2; requires same_as<decltype(b1 || b2), bool>;
        a || b2;  requires same_as<decltype(a || b2), bool>;
        b1 == b2; requires convertible_to<decltype(b1 == b2), bool>;
        b1 == a;  requires convertible_to<decltype(b1 == a), bool>;
        a == b2;  requires convertible_to<decltype(a == b2), bool>;
        b1 != b2; requires convertible_to<decltype(b1 != b2), bool>;
        b1 != a;  requires convertible_to<decltype(b1 != a), bool>;
        a != b2;  requires convertible_to<decltype(a != b2), bool>;
  };
//!\endcond

} // namespace std

namespace std::detail
{

/*!\interface   std::detail::weakly_equality_comparable_with <>
 * \tparam t1   The first type to compare.
 * \tparam t2   The second type to compare.
 * \brief       Requires the two operands to be comparable with `==` and `!=` in both directions.
 * \sa          https://en.cppreference.com/w/cpp/concepts/equality_comparable
 */
//!\cond
template <class T, class U>
SEQAN3_CONCEPT weakly_equality_comparable_with =
    requires(std::remove_reference_t<T> const & t,
             std::remove_reference_t<U> const & u)
    {
        t == u; requires boolean<decltype(t == u)>;
        t != u; requires boolean<decltype(t != u)>;
        u == t; requires boolean<decltype(u == t)>;
        u != t; requires boolean<decltype(u != t)>;
    };
//!\endcond
} // namespace std::detail

namespace std
{

using ::concepts::equality_comparable;
using ::concepts::equality_comparable_with;

using ::concepts::totally_ordered;
using ::concepts::totally_ordered_with;

// ============================================================================
//  Object concepts  part2
// ============================================================================

using ::concepts::copyable;
using ::concepts::semiregular;
using ::concepts::regular;

// ============================================================================
//  Callable concepts
// ============================================================================

using ::ranges::invocable;
using ::ranges::regular_invocable;
using ::ranges::predicate;
using ::ranges::relation;
using ::ranges::strict_weak_order;

} // namespace std

#endif // compile check

#endif // not __has_include(<concepts>)
